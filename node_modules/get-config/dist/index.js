module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 18);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var fs = __webpack_require__(15);
function exists(path) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve) {
                    fs.access(path, function (err) { return resolve(!err || err.code !== 'ENOENT'); });
                })];
        });
    });
}
exports.exists = exists;
exports.existsSync = fs.existsSync;
function isDir(path) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, lstat(path).then(function (stats) { return stats.isDirectory(); })];
        });
    });
}
exports.isDir = isDir;
function isDirSync(path) {
    return exports.lstatSync(path).isDirectory();
}
exports.isDirSync = isDirSync;
function isFile(path) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, lstat(path).then(function (stats) { return stats.isFile(); })];
        });
    });
}
exports.isFile = isFile;
function isFileSync(path) {
    return exports.lstatSync(path).isFile();
}
exports.isFileSync = isFileSync;
function lstat(path) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    fs.lstat(path, function (err, stats) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(stats);
                    });
                })];
        });
    });
}
exports.lstat = lstat;
exports.lstatSync = fs.lstatSync;
function readDir(path, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var fn = fs.readdir;
                    fn(path, options, function (err, files) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(files);
                    });
                })];
        });
    });
}
exports.readDir = readDir;
exports.readDirSync = fs.readdirSync;
function readFile(path, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    fs.readFile(path, options, function (err, data) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(data);
                    });
                })];
        });
    });
}
exports.readFile = readFile;
exports.readFileSync = fs.readFileSync;


/***/ },
/* 1 */
/***/ function(module, exports) {

module.exports = require("get-env");

/***/ },
/* 2 */
/***/ function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 2;


/***/ },
/* 3 */
/***/ function(module, exports) {

module.exports = require("ini");

/***/ },
/* 4 */
/***/ function(module, exports) {

module.exports = require("js-yaml");

/***/ },
/* 5 */
/***/ function(module, exports) {

module.exports = require("toml");

/***/ },
/* 6 */
/***/ function(module, exports) {

module.exports = require("xml2json");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var assert = __webpack_require__(14);
var path = __webpack_require__(17);
var getEnv = __webpack_require__(1);
var lodash_1 = __webpack_require__(16);
var fs_1 = __webpack_require__(0);
var ini_1 = __webpack_require__(8);
var js_1 = __webpack_require__(9);
var json_1 = __webpack_require__(10);
var toml_1 = __webpack_require__(11);
var xml_1 = __webpack_require__(12);
var yaml_1 = __webpack_require__(13);
var OVERRIDE_DIR = '_override';
function _buildLoadTasks(dir, files) {
    var result = [];
    var filesByExtName = files.reduce(function (out, file) {
        var extname = path.extname(file).toLowerCase();
        if (!(extname in out)) {
            out[extname] = [];
        }
        out[extname].push(file);
        return out;
    }, {});
    lodash_1.merge([], filesByExtName['.ini'], filesByExtName['.cfg'], filesByExtName['.conf']).forEach(function (file) {
        result.push({ filepath: path.resolve(dir, file), fn: ini_1.load, fnSync: ini_1.loadSync });
    });
    lodash_1.merge([], filesByExtName['.js']).forEach(function (file) {
        result.push({ filepath: path.resolve(dir, file), fn: js_1.load, fnSync: js_1.loadSync });
    });
    lodash_1.merge([], filesByExtName['.json']).forEach(function (file) {
        result.push({ filepath: path.resolve(dir, file), fn: json_1.load, fnSync: json_1.loadSync });
    });
    lodash_1.merge([], filesByExtName['.toml']).forEach(function (file) {
        result.push({ filepath: path.resolve(dir, file), fn: toml_1.load, fnSync: toml_1.loadSync });
    });
    lodash_1.merge([], filesByExtName['.xml']).forEach(function (file) {
        result.push({ filepath: path.resolve(dir, file), fn: xml_1.load, fnSync: xml_1.loadSync });
    });
    lodash_1.merge([], filesByExtName['.yaml'], filesByExtName['.yml']).forEach(function (file) {
        result.push({ filepath: path.resolve(dir, file), fn: yaml_1.load, fnSync: yaml_1.loadSync });
    });
    return result;
}
function _loadDir(dir) {
    return __awaiter(this, void 0, void 0, function () {
        var loadTasks, _a, _b, result, _i, loadTasks_1, task, loaded, extname, key, err_1;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = _buildLoadTasks;
                    _b = [dir];
                    return [4 /*yield*/, fs_1.readDir(dir)];
                case 1:
                    loadTasks = _a.apply(void 0, _b.concat([_c.sent()]));
                    result = {};
                    _i = 0, loadTasks_1 = loadTasks;
                    _c.label = 2;
                case 2:
                    if (!(_i < loadTasks_1.length))
                        return [3 /*break*/, 9];
                    task = loadTasks_1[_i];
                    _c.label = 3;
                case 3:
                    _c.trys.push([3, 7, , 8]);
                    return [4 /*yield*/, fs_1.isFile(task.filepath)];
                case 4:
                    if (!_c.sent())
                        return [3 /*break*/, 6];
                    return [4 /*yield*/, task.fn(task.filepath)];
                case 5:
                    loaded = _c.sent();
                    extname = path.extname(task.filepath).toLowerCase();
                    key = path.basename(task.filepath, extname);
                    result[key] = lodash_1.isFunction(loaded) ? loaded : lodash_1.merge({}, result[key], loaded);
                    _c.label = 6;
                case 6: return [3 /*break*/, 8];
                case 7:
                    err_1 = _c.sent();
                    console.error("Failed to load file: " + task.filepath);
                    throw err_1;
                case 8:
                    _i++;
                    return [3 /*break*/, 2];
                case 9: return [2 /*return*/, result];
            }
        });
    });
}
function _loadDirSync(dir) {
    var loadTasks = _buildLoadTasks(dir, fs_1.readDirSync(dir));
    var result = {};
    for (var _i = 0, loadTasks_2 = loadTasks; _i < loadTasks_2.length; _i++) {
        var task = loadTasks_2[_i];
        try {
            if (fs_1.isFileSync(task.filepath)) {
                var loaded = task.fnSync(task.filepath);
                var extname = path.extname(task.filepath).toLowerCase();
                var key = path.basename(task.filepath, extname);
                result[key] = lodash_1.isFunction(loaded) ? loaded : lodash_1.merge({}, result[key], loaded);
            }
        }
        catch (err) {
            console.error("Failed to load file: " + task.filepath);
            throw err;
        }
    }
    return result;
}
function _setup(configDir, env, cb) {
    if (cb === void 0) { cb = undefined; }
    assert(lodash_1.isString(configDir) && !lodash_1.isEmpty(configDir), '"configDir" should be a string path to a directory.');
    assert((lodash_1.isString(env) && !lodash_1.isEmpty(env)) || lodash_1.isUndefined(env), '"env" should be either a non-empty string or undefined.');
    assert(lodash_1.isFunction(cb) || lodash_1.isUndefined(cb), '"cb" should be either a callback function or undefined.');
    return {
        envDir: path.resolve(configDir, env || getEnv()),
        overrideDir: path.resolve(configDir, OVERRIDE_DIR),
    };
}
function _load(configDir, envDir, overrideDir) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b, _c, results, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        return __generator(this, function (_o) {
            switch (_o.label) {
                case 0:
                    _a = assert;
                    return [4 /*yield*/, fs_1.exists(configDir)];
                case 1:
                    _c = (_o.sent());
                    if (!_c)
                        return [3 /*break*/, 3];
                    return [4 /*yield*/, fs_1.isDir(configDir)];
                case 2:
                    _c = (_o.sent());
                    _o.label = 3;
                case 3:
                    _a.apply(void 0, [_c, "\"configDir\" should be a directory path: " + configDir]);
                    return [4 /*yield*/, _loadDir(configDir)];
                case 4:
                    results = [_o.sent()];
                    return [4 /*yield*/, fs_1.exists(envDir)];
                case 5:
                    _e = (_o.sent());
                    if (!_e)
                        return [3 /*break*/, 7];
                    return [4 /*yield*/, fs_1.isDir(envDir)];
                case 6:
                    _e = (_o.sent());
                    _o.label = 7;
                case 7:
                    if (!_e)
                        return [3 /*break*/, 9];
                    _g = (_f = results).push;
                    return [4 /*yield*/, _loadDir(envDir)];
                case 8:
                    _g.apply(_f, [_o.sent()]);
                    _o.label = 9;
                case 9: return [4 /*yield*/, fs_1.exists(overrideDir)];
                case 10:
                    _j = (_o.sent());
                    if (!_j)
                        return [3 /*break*/, 12];
                    return [4 /*yield*/, fs_1.isDir(overrideDir)];
                case 11:
                    _j = (_o.sent());
                    _o.label = 12;
                case 12:
                    if (!_j)
                        return [3 /*break*/, 14];
                    _l = (_k = results).push;
                    return [4 /*yield*/, _loadDir(overrideDir)];
                case 13:
                    _l.apply(_k, [_o.sent()]);
                    _o.label = 14;
                case 14: return [2 /*return*/, lodash_1.merge.apply(null, results)];
            }
        });
    });
}
function load(configDir, env, callback) {
    if (lodash_1.isFunction(env)) {
        callback = env;
        env = void 0;
    }
    var _a = _setup(configDir, env, callback), envDir = _a.envDir, overrideDir = _a.overrideDir;
    if (lodash_1.isFunction(callback)) {
        return _load(configDir, envDir, overrideDir)
            .then(function (result) { return callback(null, result); })
            .catch(function (err) { return callback(err); });
    }
    return _load(configDir, envDir, overrideDir);
}
exports.load = load;
function loadSync(configDir, env) {
    var _a = _setup(configDir, env), envDir = _a.envDir, overrideDir = _a.overrideDir;
    assert(fs_1.existsSync(configDir) && fs_1.isDirSync(configDir), "\"configDir\" should be a directory path: " + configDir);
    var results = [_loadDirSync(configDir)];
    if (fs_1.existsSync(envDir) && fs_1.isDirSync(envDir)) {
        results.push(_loadDirSync(envDir));
    }
    if (fs_1.existsSync(overrideDir) && fs_1.isDirSync(overrideDir)) {
        results.push(_loadDirSync(overrideDir));
    }
    return lodash_1.merge.apply(null, results);
}
exports.loadSync = loadSync;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var fs_1 = __webpack_require__(0);
function load(path) {
    return __awaiter(this, void 0, void 0, function () {
        var ini, content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    try {
                        ini = __webpack_require__(3);
                    }
                    catch (err) {
                        throw new Error('Please install INI parser: `npm install ini`');
                    }
                    return [4 /*yield*/, fs_1.readFile(path, { encoding: 'utf8' })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, ini.parse(content)];
            }
        });
    });
}
exports.load = load;
function loadSync(path) {
    var ini;
    try {
        ini = __webpack_require__(3);
    }
    catch (err) {
        throw new Error('Please install INI parser: `npm install ini`');
    }
    var content = fs_1.readFileSync(path, { encoding: 'utf8' });
    return ini.parse(content);
}
exports.loadSync = loadSync;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function load(path) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())];
        });
    });
}
exports.load = load;
function loadSync(path) {
    return !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
}
exports.loadSync = loadSync;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var fs_1 = __webpack_require__(0);
function load(path) {
    return __awaiter(this, void 0, void 0, function () {
        var content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fs_1.readFile(path, { encoding: 'utf8' })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, JSON.parse(content.toString())];
            }
        });
    });
}
exports.load = load;
function loadSync(path) {
    var content = fs_1.readFileSync(path, { encoding: 'utf8' });
    return JSON.parse(content);
}
exports.loadSync = loadSync;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a = __webpack_require__(0), readFile = _a.readFile, readFileSync = _a.readFileSync;
function load(path) {
    return __awaiter(this, void 0, void 0, function () {
        var toml, content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    try {
                        toml = __webpack_require__(5);
                    }
                    catch (err) {
                        throw new Error('Please install TOML parser: `npm install toml`');
                    }
                    return [4 /*yield*/, readFile(path, { encoding: 'utf8' })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, toml.parse(content)];
            }
        });
    });
}
exports.load = load;
function loadSync(path) {
    var toml;
    try {
        toml = __webpack_require__(5);
    }
    catch (err) {
        throw new Error('Please install TOML parser: `npm install toml`');
    }
    var content = readFileSync(path, { encoding: 'utf8' });
    return toml.parse(content);
}
exports.loadSync = loadSync;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var fs_1 = __webpack_require__(0);
function load(path) {
    return __awaiter(this, void 0, void 0, function () {
        var xml2json, content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    try {
                        xml2json = __webpack_require__(6);
                    }
                    catch (err) {
                        throw new Error('Please install XML parser: `npm install xml2json`');
                    }
                    return [4 /*yield*/, fs_1.readFile(path, { encoding: 'utf8' })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, xml2json.toJson(content, { object: true })];
            }
        });
    });
}
exports.load = load;
function loadSync(path) {
    var xml2json;
    try {
        xml2json = __webpack_require__(6);
    }
    catch (err) {
        throw new Error('Please install XML parser: `npm install xml2json`');
    }
    var content = fs_1.readFileSync(path, { encoding: 'utf8' });
    return xml2json.toJson(content, { object: true });
}
exports.loadSync = loadSync;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var fs_1 = __webpack_require__(0);
function load(path) {
    return __awaiter(this, void 0, void 0, function () {
        var yaml, content;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    try {
                        yaml = __webpack_require__(4);
                    }
                    catch (err) {
                        throw new Error('Please install YAML parser: `npm install js-yaml`');
                    }
                    return [4 /*yield*/, fs_1.readFile(path, { encoding: 'utf8' })];
                case 1:
                    content = _a.sent();
                    return [2 /*return*/, yaml.safeLoad(content)];
            }
        });
    });
}
exports.load = load;
function loadSync(path) {
    var yaml;
    try {
        yaml = __webpack_require__(4);
    }
    catch (err) {
        throw new Error('Please install YAML parser: `npm install js-yaml`');
    }
    var content = fs_1.readFileSync(path, { encoding: 'utf8' });
    return yaml.safeLoad(content);
}
exports.loadSync = loadSync;


/***/ },
/* 14 */
/***/ function(module, exports) {

module.exports = require("assert");

/***/ },
/* 15 */
/***/ function(module, exports) {

module.exports = require("fs");

/***/ },
/* 16 */
/***/ function(module, exports) {

module.exports = require("lodash");

/***/ },
/* 17 */
/***/ function(module, exports) {

module.exports = require("path");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var getEnv = __webpack_require__(1);
exports.env = getEnv;
var loader_1 = __webpack_require__(7);
exports.load = loader_1.load;
exports.loadSync = loader_1.loadSync;


/***/ }
/******/ ]);